# C++的学习 #

## 数据类型 ##

C++规定创建一个常量或变量的时候必须指定数据类型，否则无法分配内存。

### 整型 ###

整型变量表示“整数类型”的数据。

C++中能表示整型的类型的区别在于所占内存空间不同：
	
	short(短整型)	2字节	(-2^15 ~ 2^15-1)
	int(整型)	4字节	(-2^31 ~ 2^31-1)
	long(长整形)	Windows为4字节，Linux为4字节(32位)，8字节(64位)	(-2^31 ~ 2^31-1)
	long long(长长整形)	8字节	(-2^63 ~ 2^63-1)

### sizeof关键字 ###

利用sizeof关键字可以统计数据类型所占大小。

sizeof（数据类型/变量）

### 实型（浮点型） ###

用于表示小数。

浮点型变量分为两种：
1、单精度浮点型：float。
2、双精度浮点型：double。

区别在于占用空间和表示的有效数字范围不一样。

float 占用4个字节 表示7位有效数字。
double 占用8个字节 表示15~16位有效数字。

### 字符型 ###
字符型变量用于显示单个字符。

char ch = ‘a’；
显示字符型变量用单引号括起来，并不是用双引号。
单引号内只能是字符不能是字符串。
字符型变量不是把字符本身放进内存存储，而是存储字符对应的ASCII编码到存储单元。

### ASCII编码 ###

ASCII非打印控制字符：ASCII上的数字0~31分配给了控制字符，用来控制外围设备。

ASCII打印字符：ASCII上的数字32~126分配给了键盘上的字符。

### 转义字符 ###
用来表示一些不能显示出来的ASCII字符。

\a	警报	007
\b	退格(BS) ，将当前位置移到前一列	008
\f	换页(FF)，将当前位置移到下页开头	012
\n	换行(LF) ，将当前位置移到下一行开头	010
\r	回车(CR) ，将当前位置移到本行开头	013
\t	水平制表(HT) （跳到下一个TAB位置）	009
\v	垂直制表(VT)	011
\\	代表一个反斜线字符""	092
'	代表一个单引号（撇号）字符	039
"	代表一个双引号字符	034
?	代表一个问号	063
\0	数字0	000
\ddd	8进制转义字符，d范围0~7	3位8进制
\xhh	16进制转义字符，h范围09，af，A~F	3位16进制

### 字符串型 ###
用来表示一串字符。

C风格字符串： char 变量名[] = “字符串值”

C++风格字符串： string 变量名 = “字符串值”

### bool布尔类型 ###
布尔类型代表真或假的值。

bool类型只有两个值：true（1）和false（0）.

bool类型占一个字节大小。

### 数据的输入 ###
用于从键盘获取数据。

cin >> 变量

### 运算符 ###
用来执行代码的运算

算术运算符：用来处理四则运算
赋值运算符：用来将表达式的值赋给变量
比较运算符：用来比较表达式，并返回一个真值或假值。
逻辑运算符：根据表达式的值返回真值或假值。

### 算术运算符 ###
用来处理四则运算。
```
+	正号	+3	3
-	负号	-3	-3
+	加	10 + 5	15
-	减	10 - 5	5
*	乘	10 * 5	50
/	除	10 / 5	2
%	取模(取余)	10 % 3	1
++	前置递增	a=2; b=++a;	a=3; b=3;
++	后置递增	a=2; b=a++;	a=3; b=2;
--	前置递减	a=2; b=--a;	a=1; b=1;
--	后置递减	a=2; b=a--;	a=1; b=2;
```

**只有整型变量才可以取模运算。**
**前置递增先对变量++再计算表达式，后置递增反之**

### 赋值运算符 ###
用于将表达式的值赋给变量。
```
=	赋值	a=2; b=3;	a=2; b=3;
+=	加等于	a=0; a+=2;	a=2;
-=	减等于	a=5; a-=3;	a=2;
*=	乘等于	a=2; a*=2;	a=4;
/=	除等于	a=4; a/=2;	a=2;
%=	模等于	a=3; a%2;	a=1;
```
### 比较运算符 ###
```
==	相等于	4 == 3	0
!=	不等于	4 != 3	1
<	小于	4 < 3	0
>	大于	4 > 3	1
<=	小于等于	4 <= 3	0
>=	大于等于	4 >= 1	1
```

### 逻辑运算符 ###

```
!	非	!a	如果a为假，则!a为真； 如果a为真，则!a为假。
&&	与	a && b	如果a和b都为真，则结果为真，否则为假。
||	或	a || b	如果a和b有一个为真，则结果为真，二者都为假时，结果为假。
```

### 程序流程结构 ###

C/C++支持最基本的三种程序允许结构：
顺序结构：程序按顺序进行不发生跳转。
选择结构：根据条件是否满足，选择执行相应的功能。
循环结构：根据条件是否满足，循环允许某段代码。

### 选择结构 ###
#### if语句 ####
执行满足条件的语句。
1、单行if语句：

```
if （条件）{

条件满足执行的语句

}
```

**注意：if表达式之后切记不能加分号。**

2、多行格式if语句：

```
if （条件）{

条件满足执行语句

}

else{

条件不满足执行语句

}；
```

3、多条件的if语句：

```
if （条件1）{

条件1满足执行语句

}

else if （条件2）{

条件2满足执行的语句

}
...

else{

都不满足执行的语句

}
```
#### 嵌套if语句 ####
在if语句种，可以嵌套使用if语句，达到更精准的条件旁段


#### 三目运算符 ####

通过三目运算符实现简单的判断

表达式1 ？ 表达式2 ：表达式3

如果表达式1的值为真，执行表达式2并放回表达式2的结果。
如果表达式1的值为假，执行表达式3并返回表达式3的结果。

**和if语句相比，三目运算符短小整洁，但使用嵌套的话结构会不清晰。**

#### switch语句 ####
执行多条件分支语句。

    
	switch （表达式）{
	
	case 结果1：执行语句；break；

	case 结果2：执行语句；break；

	...	

	default：执行语句；break；

	}

	
	
**switch语句的表达式类型只能是整型或者字符型。**
**case里如果没有break，程序会一直向下执行。**

**与if语句相比，多条件判断时，switch结构清晰，执行效率高，但不可以判断区间。**

### 循环结构 ###

#### while循环语句 ####
满足循环条件，执行循环语句。

while（循环条件）{循环语句}

只要循环条件为真就执行循环语句。

**执行循环语句的时候，程序必须提供跳出循环的出口，防止出现死循环。**

#### do···while ####

满足循环条件，执行循环语句。

do{ 循环语句 }
while{循环条件}；

**与while的区别在于，do···while先执行一次循环语句再判断循环条件。**

#### for循环语句 ####
满足循环条件，执行循环语句。

    
	for（起始表达式；条件表达式；末尾循环体）{

	循环语句；

	}

起始表达式先执行一次，然后判断条件表达式若为真执行循环语句，然后执行末尾循环体，然后再判断条件表达式，如真执行循环语句...，若假退出循环。
    

**注意：for循环的表达式要用分号分隔。**

#### 嵌套循环 ####

在循环体中再嵌套一层循环。

### 跳转语句 ###

#### break语句 ####

用于跳出“选择结构”或“循环结构”。

break使用时机：

1、出现switch条件语句中，终止case并跳出switch。

2、循环语句中，跳出当前循环语句。

3、嵌套循环中，跳出最近的内层循环语句。

#### continue语句 ####

在“循环语句”中，跳过本次循环未执行完的语句，继续执行下次循环。

**continue语句没有使整个循环终止，而break会跳出循环。**

#### goto语句 ####

goto可以无条件跳转语句。

goto 标记；

如果标记的名称存在，执行到goto语句的时候，会跳转到标记名称的位置。

### 数组 ###
数组指的是一个集合，里面存放了相同类型的数据元素。

特点1：数组内每个数据元素都是相同的数据类型。

特点2：数组是由连续的内存位置组成的。

#### 一维数组 ####

1、数据类型 数组名[ 数组长度 ]；

2、数据类型 数组名[ 数组长度 ] = { 值1， 值2 ...}；

3、数组类型 数组名[  ] = { 值1， 值2 ...}；

**总结1：数组名的命名规范和变量名规范一样，不能和变量重名。**

**总结2：数组中下标以开始索引。**

#### 一维数组的数组名 ####

作用：
1、统计整个数组在内存的长度。
2、获取数组在内存的首地址。

**数组名是常量不能赋值。**

**直接打印数组名，可以查看数组所占内存首地址。**

**对数组名进行sizeof，可以获取整个数组所占内存空间大小**

#### 冒泡排序 ####

最常用的排序算法，对数组内元素进行排序。

1、比较相邻元素，如果第一个比第二个大则交换他们两个。

2、对每一对相邻数组执行这个操作，执行完成后找到第一个最大值。

3、重复以上步骤，每次比较次数-1，直到不需要比较。

** 将一个数组进行升序排序的实例。 **

	int main（）{

		int num[x]={a，b，...，f}；
		
		for （int i=0；i < x -1 ；i++）//这一步是第一个循环语句他先定义了一个数，对数组进行x-1次排序。
		{
				for （int j = 0；j<9-1-i；j++）//每次排序要排序的数字个数。
				{
						if （num[x]>num[x+1]）
						{
							int temp=num[x]；
							num[x]=num[x+1]；
							num[x+1]=temp；
						 }
				}
		}//如果数列前面的大于数列后面的，将其交换。


### 二维数组 ###

二维数组的定义方法：

1、数据类型 数组名[ 行数 ][ 列数 ]；

2、数据类型 数组名[ 行数 ][ 列数 ]={ {数据1，数据2}，{数据3，数据4}}；

3、数据类型 数组名[ 行数 ][ 列数 ]={ 数据1，数据2，数据3，数据4 }；

4、数据类型 数组名[  ][ 列数 ] ={
数据1，数据2，数据3，数据4}；

	#include <iostream>
	#include <stdio.h>
	using namespace std;
	int main()
    {int num[3][3]={
        {1,2,3},
        {4,5,6},
        {7,8,9}
    };	//	定义一个二维数值，数组有三行三列，用逗号将每行数组分隔开。
    cout<< *num[0][0]<<endl;//输出第1行第一列的数组内容，如果不加*，输出的是数组的地址。
    }


**定义二维数组时，如果初始化了数据，可以省略行数。**

#### 二维数组数组名 ####

1、查看二维数组所占内存空间。

2、获取二维数组首地址。

**二维数组组名就是这个数组的首地址。**


### 函数 ###

将一段经常使用的代码封装起来，减少重复代码。

#### 函数定义 ####

1、返回值类型

2、函数名

3、参数表列

4、函数体语句

5、return表达式

    返回值类型 函数名 （参数列表）
	{
		
			函数体语句

			return 表达式

	}

返回值类型：一个函数可以返回一个值。

函数名：给函数定义一个名字，最好这个名字可以让别人识别作用。

参数列表：使用函数时传入的数据。

函数体语句：{}内的内容，函数内要执行的语句。

return表达式：和返回值挂钩，函数执行完成后，返回对应的数据。

#### 函数调用 ####

使用已定义的函数实现功能。

函数名（参数）

**函数定义的小括号内为形参，函数调用时传入的参数为实参。**

### 值传递 ###

值传递：函数调用时实参将数值传入给形参。

值传递时，形参修饰不了实参。

#### 函数常见样式 ####

1、无参无返

2、有参无返

3、无参有返

4、有参有返


#### 函数的声明 ####

告诉编译器函数名称以及如何调用函数，函数实际主体可以单独定义。

**函数可以声明多次。但只能有一个定义。**

#### 函数的分文件编写 ####

函数分文件编写可以让代码结构更加清晰。

函数分文件编写的四个步骤：

1、创建后缀名为.h的头文件。

2、创建后缀名为.cpp的源文件。

3、头文件写函数的声明。

4、源文件写函数定义。

### 指针 ###

作用：可以通过指针间接访问内存。

内存编号是从0开始记录的，一般用十六进制数字表示。

可以利用指针变量保存地址。

#### 指针变量的定义和使用 ####

指针变量定义：
数据类型 * 变量名；

指针变量和普通变量的区别：

普通变量存放数据，指针变量存放地址。

指针变量可以通过“*”操作符操作指针变量指向内存空间，这个过程叫解引用。

**可以通过&符号获取变量地址。**

**利用指针可以记录地址。**

**对指针变量解应用，可以操作指针指向的内存。**

#### 指针所占内存空间 ####

所有指针类型在32位操作系统是4个字节。
所有指针类型在64位操作系统是8个字节。

### 空指针和野指针 ###

#### 空指针 ####

空指针：指针变量指向内存中编号位为0的空间。

用法：初始化指针变量。

注意：空指针指向的地址是不可以访问的。

#### 野指针 ####

**空指针和野指针是我们申请的空间，因此不要访问。**

### const修饰指针 ###

const修饰指针有三种情况：

1、const修饰指针 —— 常量指针。
2、const修饰常量 —— 指针常量。
3、const修饰指针又修饰常量。

** const跟着的是指针的话是常量指针，是常量的话就是执政常量。 **

### 指针和数组 ###

利用指针访问数组中的元素。

### 指针和函数 ###

利用指针作函数参数，可以修改实参的值。

**不想修改实参就用值传递，如果想修改实参就用地址传递。**

### 指针、数组、函数 ###

**当数组名传入函数当参数时，数组名退化为指向首元素的指针。**

### 结构体 ###

#### 结构体概念 ####

结构体属于用户**自定义的数据类型**，允许用户存储不同的数据类型。

#### 结构体的定义和使用 ####

	struct 结构体名 {结构体成员列表}

	struct students
	{	
		string name；
		int age；
		int score；
	}；
	

	int mian（）{

			struct students stu1；

			stu1.name = “张三”；
			stu1.age = 18；
			stu.score = 100；

			cout <<“名字：”<< stu1.name <<“年龄：”<< stu1.age << “分数” << stu1.score <<endl;

			return 0；
		}

**定义结构体的关键字是struct。**
**创建结构体变量时，关键字struct可以省略。**
**结构体变量利用操作符"."访问成员。**

### 结构体数组 ###

将自定义结构体放入数组以方便维护。

	struct 结构体名 数组名[元素个数] = {
		{}，
		{}
		{}
		}

### 结构体指针 ###

利用指针访问结构体中的成员。

利用操作符->可以通过结构体指针访问结构体属性。

**结构体指针可以通过->操作符访问结构体中的成员。**


### 结构体嵌套结构体 ###

结构体中的成员是另一个结构体。


### 结构体做函数参数 ###

将结构体作为参数向函数中传递。

传递方式：

值传递、地址传递。

**如果不想修改主函数的数据就用值传递，反之使用地址传递。**


### 结构体中const的使用场景 ###

用const防止误操作。


