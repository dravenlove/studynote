# Erlang的学习2 #

## 给并发建模 ##

假设现在有4个人,5条狗和6只兔子.四个人在散步聊天,而狗与兔子在追踪.

1.根据条件,有4个模板,分别为狗(dog),兔子(rabbit),人(person),世界(world).

2.person的代码放在person.erl里
文件:

```
-module(person).
-export([init/1]).

init(Name) -> ...
```

-module(person).的意思是此文件用于person模板代码,文件名要与模板名一致,这是模板声明代码.

** 注意:模板名必须以一个小写字母开头,模板名是一个原子. **

模板声明后是导出声明,导出声明指明了模板里的某些函数可以从模板外部调用,类似于C++的public声明,没有在导出声明的函数是私有的,相当于C++的private,无法在模块外调用.

-export([init/1]).的意思是带有一个参数的函数init可以在模板外调用,如果想导出多个函数应该用下面语法:

```
-export([Fun1/N1,Fun2/N2,...]).
```

方括号[...]的意思是列表,所以我们在这行命令中导出一个函数列表.

我们完成了给person编写好模板声明和导出声明后还需要给dog和rabbit编写类似的代码.

3.需要启动程序,可以调用world:start().
world:start定义在world的模板内,

world的模板类似于下面:


```
-module(world).
-export([start/0]).

start() ->
    Draven  = spawn(person, init, ["Draven"]),
    Luck    = spawn(person, init, ["Luck"]),
    ...
    Burk    = spawn(dog, init, ["Burk"]),
    ...
    UBit    = spawn(rabbit, init ,["UBit"]),
    ...
```


spawn是一个Erlang的基本函数,他创建一个并发进程并返回一个进程标识符.

spawn也可以导入多个参数:


```
    spawn(模块名称,函数名,[参数1,参数2,...,参数N]).
```   
    
当Erlang运行时系统执行spawn函数时,他会创建一个新的进程(这个进程不是系统进程而时一个Erlang管理的轻量级进程).进程创建完成后,开始执行参数指定的代码.模板名包含想执行代码的模板名.函数名时模板里的函数名,[参数1,参数2,...,参数N]时一个列表,包含了要执行的函数参数.

下面的调用的意思是启动一个执行函数person:init("Draven")的进程:
spawn(person,init,["Draven"])

spwan的返回值是一个进程标识符(PID),它可以用来与新创建的进程交互.

**Erlang的模块类似C++的类,进程类似C++的对象(类创建的对象).**

**Erlang的spawn通过运行模块里定义的函数创建新进程, Java通过运行类中定义的方法创建一个新对象.**

4.发送信息

启动模拟后,我们需要程序进程间发送消息.Erlang的各个进程不共享内存,只能通过发送消息与其他进程交互.

假设Draven想和Luck聊什么:

Luck ! {self(),"what are u doing"}

Pid ! Msg语法:发送信息Msg到进程Pid,大括号里的self()参数标明发送消息的进程(Draven).

5.接收信息

为了让Luck的进程接收到来自Draven的信息:

```
receive
    {From,Message} ->
        ...
end
```

当Luck进程收到信息,变量From会绑定为Draven这样Luck就知道信息的来源,变量Message会包含此信息.

**编程模型基于对现实世界观察,之所以有三个模块(人,狗,兔子)是因为例子里有三种并发的事物,World模块的作用是让一个顶级进程来启动全部进程,创建多少个进程代表有多少个事物,程序的消息则代表我们能在例子里观察到的消息.**
 
## 并发的好处 ## 

并发编程可以提升性能,创建可扩展和容错的系统,以及编写清晰和可理解的程序控制现实世界的应用:

1.性能:
    有两个任务A任务需要10秒执行,B任务需要15秒执行,在单个CPU上执行需要25秒,但是在两个可以独立运行的CPU上只需要15秒,所以要实现性能提升,必须编写并发程序.

2.可扩展性:
    并发程序由多个小型的独立进程组成,增加进程数和添加更多的CPU可以轻松扩展系统,运行时,Erlang虚拟机会自动在可用的CPU之间分配进程的执行.

3.容错性:
    容错性和可扩展性类似.容错的关键是独立性和硬件冗余,Erlang由多个小型独立进程组成,一个进程的错误不会导致另一个进程崩溃,为防止整台计算或数据中心发送故障,需要进行远程计算机故障探查,独立进程和远程故障探测都在Erlang的虚拟机中.

4.清晰性:
    代码和现实世界一样都是并行的,比较清晰容易理解.

## 并发程序和并行计算机 ##

并发程序(有并行计算机可以运行的更快的程序)和多核或多个CPU的并行计算机.

并发程序是一种用并发编程语言写的程序.并发语言目的为了提升性能和可扩展性以及容错性.

并发程序有专门编写并发程序的语言结构,这些结构是编程语言的主要部分,在所有的操作系统上都有相同的表现.

并行计算机是一种由多个处理单元(CPU或核心)同时运行的计算机.

Erlang的并发程序是由互相通信的多组顺序进程组成的,一个Erlang进程就是一个小小的虚拟机可以执行单个Erlang函数,别把它和操作系统的进程混淆.
