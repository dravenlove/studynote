# Erlang的学习2 #

## 给并发建模 ##

假设现在有4个人,5条狗和6只兔子.四个人在散步聊天,而狗与兔子在追踪.

1.根据条件,有4个模板,分别为狗(dog),兔子(rabbit),人(person),世界(world).

2.person的代码放在person.erl里
文件:

```
-module(person).
-export([init/1]).

init(Name) -> ...
```

-module(person).的意思是此文件用于person模板代码,文件名要与模板名一致,这是模板声明代码.

** 注意:模板名必须以一个小写字母开头,模板名是一个原子. **

模板声明后是导出声明,导出声明指明了模板里的某些函数可以从模板外部调用,类似于C++的public声明,没有在导出声明的函数是私有的,相当于C++的private,无法在模块外调用.

-export([init/1]).的意思是带有一个参数的函数init可以在模板外调用,如果想导出多个函数应该用下面语法:

```
-export([Fun1/N1,Fun2/N2,...]).
```

方括号[...]的意思是列表,所以我们在这行命令中导出一个函数列表.

我们完成了给person编写好模板声明和导出声明后还需要给dog和rabbit编写类似的代码.

3.需要启动程序,可以调用world:start().
world:start定义在world的模板内,

world的模板类似于下面:


```
-module(world).
-export([start/0]).

start() ->
    Draven  = spawn(person, init, ["Draven"]),
    Luck    = spawn(person, init, ["Luck"]),
    ...
    Burk    = spawn(dog, init, ["Burk"]),
    ...
    UBit    = spawn(rabbit, init ,["UBit"]),
    ...
```


spawn是一个Erlang的基本函数,他创建一个并发进程并返回一个进程标识符.

spawn也可以导入多个参数:


```
    spawn(模块名称,函数名,[参数1,参数2,...,参数N]).
```   
    
当Erlang运行时系统执行spawn函数时,他会创建一个新的进程(这个进程不是系统进程而时一个Erlang管理的轻量级进程).进程创建完成后,开始执行参数指定的代码.模板名包含想执行代码的模板名.函数名时模板里的函数名,[参数1,参数2,...,参数N]时一个列表,包含了要执行的函数参数.

下面的调用的意思是启动一个执行函数person:init("Draven")的进程:
spawn(person,init,["Draven"])

spwan的返回值是一个进程标识符(PID),它可以用来与新创建的进程交互.

**Erlang的模块类似C++的类,进程类似C++的对象(类创建的对象).**

**Erlang的spawn通过运行模块里定义的函数创建新进程, Java通过运行类中定义的方法创建一个新对象.**

4.发送信息

启动模拟后,我们需要程序进程间发送消息.Erlang的各个进程不共享内存,只能通过发送消息与其他进程交互.

假设Draven想和Luck聊什么:

Luck ! {self(),"what are u doing"}

Pid ! Msg语法:发送信息Msg到进程Pid,大括号里的self()参数标明发送消息的进程(Draven).

5.接收信息

为了让Luck的进程接收到来自Draven的信息:

```
receive
    {From,Message} ->
        ...
end
```

当Luck进程收到信息,变量From会绑定为Draven这样Luck就知道信息的来源,变量Message会包含此信息.

**编程模型基于对现实世界观察,之所以有三个模块(人,狗,兔子)是因为例子里有三种并发的事物,World模块的作用是让一个顶级进程来启动全部进程,创建多少个进程代表有多少个事物,程序的消息则代表我们能在例子里观察到的消息.**
 

 