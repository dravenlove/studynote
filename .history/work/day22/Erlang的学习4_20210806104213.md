# 基本概念 #

## 启动和停止Erlang shell ##

Unix类系统里用erl来启动Erlang shell,window则是通过电机Window的Erlang图标来启动.

停止Erlang shell的方法是用ctrl+c.

停止系统以a退出可能会损坏某些数据,以q退出可以受控关闭所有打开的文件都会刷入缓存并关闭,数据库停止,所有程序以有序方式关闭,q()是init:stop()命令在shell的别名.

立即停止系统用erlang:halt().

### 在shell里执行命令 ###

在Erlang shell中,第一行为1>,输入表达式``X=20. ``,shell会打印出结果.

在Erlang中%是注释的起点,Erlang编译器和shell会将他们忽略.

### Erlang shell的快捷键命令 ###

Ctrl+A:行首

Ctrl+D:删除当前字符

Ctrl+E:行尾

Ctrl+F:向前字符

Ctrl+B:向后字符

Ctrl+↑:前一行

Ctrl+↓:后一行

tab:快速补全

## 简单的整数运算 ##

Erlang整数运算精确,无需担心运算溢出.

## 变量 ##

可以把某个结果存在变量里,但是变量不能再次存入,相当于常量.

X=10. 

X不是一个变量,=不是赋值操作符,是一个模式匹配操作符.

Erlang的变量是一次赋值变量,它只能被赋值一次,如果想赋值之后再次赋值,编译器或Erlang shell会报错.

已被指派值的变量叫绑定变量,未指派值的变量叫未绑定变量.

未绑定变量就像一个等待填充的空槽一样,一旦绑定一个值就会永久保留它.

=是一个模式匹配操作符.变量的作用域是他定义时所处的词汇单元,如果X被用在单独的函数子句内,它的值只在这个子句内才能用,不是全局变量.如果X出现在不同的函数里面,他们都不相干.

### 变量绑定和模式匹配 ###

Erlang中,变量获得值是一次成功的模式匹配操作的结果.

变量是模式的一种简单形式,如之前所说,变量只能赋值一次,Lhs=Rhs是把右边的值计算出来,然后将结果与左侧的模式相匹配.

没有副作用意味着可以让程序并行,可以修改的内存区域有个专业术语叫可变状态,Erlang是一种函数式编程语言具有不可变状态.

### 一次性赋值的优点 ###
Erlang中,变量是对某个值的引用:Erlang的实现方式为指针代表绑定变量,指向一个包含值的存储区,该值不能被改变.

这个值不能改变很重要,和C和Java这些命令式语言存在区别.

使用不可变变量简化调试工作.

程序出错的最主要方式是某个变量有意料之外的值,一旦发现某个变量出错就必须检查程序找到绑定变量的地方,因为Erlang的变量是不可变的,所以生成改变这个变量的代码肯定是错的,命令式语言中,变量可以多次修改,这样每个修改变量的地方都有可能发生错误,而Erlang只有定义变量的地方有可能发生,寻找Bug的方式变得简单了.

## 浮点数 ##
    
当给两个整数做除法,结果会自动转换成浮点数,因此5/3的值是1.6666666666667.

要在除法中获得整数结果必须用div和rem来获得.

5 div 3.
结果为1,自动舍去余数.

5 rem 3.
结果为2,自动补全余数.

Erlang内部用64位IEEE 754-1986浮点数,因此浮点数程序会有C语言一样的浮点数取整和精度的问题.

## 原子 ##

Erlang中,原子被用来表示常量值.原子是全局性的,不需要定义或者包含文件就可以实现.

原子以小写字母开头,也可以放在'号内,这样就可以创建以大写字母开头的原子,否则会被解释为变量,如'Monday',,可以给不需要引号的原子加引号,结果是a和'a'是一样的.

单引号用于定义原子,双引号用于给字符串字面量定界.

一个原子的值是他本身,如果输入一个原子为命令,Shell会打印这个原子的值.


## 元组 ##

元组:把一定数量的固定项目归组成单一的实体.

创建元组的方法:用大括号把相表达的值括起来,用逗号分割他们.
如{joe,1.82},元组和数组不一样的地方是元组括起来的不一定是同样的值,如例子就有一个原子和一个浮点数.

元组类似C的struct,区别是元组的匿名的,而struct是公开的.

```
    struct point {
        int x;
        int y;
    }P;
```

C中用点操作符访问P.x=1;P.y=1;

Erlang中直接用P={1,1}. 就可以完成坐标点定义.

为了让人更容易明白我们通常在第一个元组元素添加作用缩写这是一种很好的编程风格P={point,1,1}. 

元组也可以嵌套,Person = {person,(name,joe),{height,2.00}}. 

### 创建元组 ###

元组在声明的时候自动创建,不使用时自动销毁.

Erlang用垃圾收集器回收所有未使用的内存.

如果在构建新元组的时候用到变量,那么新元组会共享变量所引用数据结构的值.
```
F={firstName,joe}. 
L={lastname,sanmu}. 
P={person,F,L}. 
```
如果想用未定义的变量创建数据结构会报错,报错是变量名没定义.


### 提取元组的值 ###

```
Point = {point,1,1}. 

{point,X,Y}=Point. 
```

他会自动把值匹配绑定X和Y.

常见错误:
```
Point = {point,1,1}. 

{point,D,D} ={point,1,1}. 
%%上述代码是可以的因为把D都模式匹配给了1.

Key ={Key,1,2}. 

{key,F,F}={point,1,2}. 
%%这样会报错因为F不能模式匹配给两个值.
```

```
Person = {person,{neme,joe,sanmu},{footsize,44}}. 

%%我们用以下代码提取该人的人名.

{_,{_,Who,_},_}=Person. 

Who. 

%%Shell将自动打印Who所得的值joe.
```

## 列表 ##

列表(list)用来存放任意数量的事物.

创建列表的方法是用中括号把列表元素括起来用逗号分隔他们.

列表的各个元素可以是任意类型.

### 专业术语 ###

表头(head):列表的第一个元素.

表尾(tail):列表除了第一个元素剩下的元素.

### 定义列表 ###

如果T是一个列表[H|T]也将是一个列表,头是H,尾是T,他们用竖线|把列表头和列表尾分割开,[]是一个空列表.

用[....|T]构建列表,应该保证T是列表,否则将会创建不正确的列表.

[E1,E2,...|T]这种写法是为了在表头添加多个元素的.

### 提取列表元素 ###

我们用模式匹配操作符提取列表里的某个元素,有个非空列表T,当[X|Y]=T,X会提取T的表头而Y会提取T的表尾.如"
```
T=[1,2,3,4,5]. 
[X|Y]=T. 
%%X将=1.
%%Y=[2,3,4,5]. 

```

```
T=[1,2,3,4,5]. 
[X,Y|Z]=T. 
&&X=1. Y=2. Z=[3,4,5]. 
```

## 字符串 ##

Erlang中没有字符串,要表示字符串可以选择一个整数组成的列表和一个二进制型,当字符串表示为整数列表时,列表的每个元素都代表一个Unicode代码点.

可以用字符串字面量创建一个表示字符串的整数列表,字符串字面量就是用双引号围起来的一串字符.

Erlang只能用双引号,不能用单引号创建字符串字面量.

当shell打印某个列表的值得时候,如果每个值都代表可以打印的字符,他就会打印成字符串变量,否则打印成列表记法.

可以用美元符号$+所需要的字符来获取对应的ASCII代码,如用``$ . ``可以获取空格的ASCLL码.

Erlang在打印的时候会自动把列表内的ASCII码转换为字符串字面量,当然前提是列表里的所有值都是ASCII码如果有一个表示ASCII码都只会打印列表本身.
如:
```
[1,2,3,4]. 
%%打印[1,2,3,4]

[83,84,85]. 
%%打印""




