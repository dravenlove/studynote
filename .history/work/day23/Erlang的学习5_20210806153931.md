# 模块与函数 #

**模块和函数是构建顺序和并行程序的基本单元,模块包含函数,而函数可以顺序或并行运行.**

## 模块定义 ##

模块是存放代码的地方,模块是Erlang的基本代码单元.模块保存在扩展名为.erl文件里,这个文件要先编译才能运行,编译后模块以.beam为扩展名,就像.cpp编译后编程.exe一样.

下面的例子是创建一对数据结构,分别代表长方形和正方形,然后拆开数据结构提取长方形和正方形的边长.

```
Rectangle = {rectangle,10,5}. 
%%定义一个长方形,第一个数据描述,第二个为长,第三个为宽.

Square = {square,5}. 
%%定义一个正方形,第一个数据描述,第二个为边长.

{rectangle,Width,Height}=Rectangle. 
%%用这个模板提取长方形的长和宽数据.

{square,Side}=Square. 
%%用这个模板提取正方形的边长数据.
```

我们把这个函数写入到模块中,我们把模块命名为geometry.erl:

```
-module(geometry). 
%%模板声明,模板声明必须和文件名一样.
-export([area/1]). 
%%导出声明,带有1个参数的area函数.
%%没有在函数中导出的函数只能在模板内部使用,导出后相当于public大家都可以用.

%%area有两个子句,他们有;来隔开,每条子句都有一个头部和一个主体,头部和主体用(->)分隔.
%%头部半酣函数名,后面接零个或多个模式,主体包含表达式,他们会在头部模式与调用参数成功匹配时执行,子句根据函数定义出现的顺序进行匹配.

area({rectangle,Width,Height}) -> Width * Height;
%%当执行函数geometry:area({rectangle,5,5})会自动执行主体语句,并返回主体最后一条表达式的值,这里会返回25.
area({square,Side})             -> Side  * Side.
```

编译上述模块并运行它.
编译用c(geometry). 
运行测试用代码``geometry:area({square,10}). ``

### 常见错误 ###

c(geometry). 只可以在shell工作不可以放入模块中.
如果不小心选择了系统模块相同的模块名,编译模块的时候会报错:不能加载sticky directory的模块,这时候只需要重新命名模块并删除编译文件重新编译即可.

### 目录和代码路径 ###

``pwd(). ``打印当前目录.

``ls(). ``显示当前工作目录所有的文件名.

``cd(Dir). ``将当前工作目录修改到Dir处.

### 给代码添加测试 ###

```
-module(geometry). 
-export([test/0,area/1]). 

test() -> 
    12 = area({rectangle,3,4}), 
    %%这是一行代码测试.如果它没有返回12,会返回一条错误信息.
    144 = area({square,12}), 
    %%同理.
    tests_worked.
    %%当返回这个信息,表示测试全部通过.


area({rectangle,Width,Height}) -> Width * Height;
%%当执行函数geometry:area({rectangle,5,5})会自动执行主体语句,并返回主体最后一条表达式的值,这里会返回25.
area({square,Side})             -> Side  * Side.
```

### 扩展程序 ###

想为这个计算面积的函数添加计算圆的.
```
area({circle,Radius})   ->3.14159*Radius*Radius. 
```
**注意:子句的顺序不重要,因为他们都是互斥的相当于重构函数,同一个函数名不同参数,不过,子句调用参数进行模式匹配的顺序就是文件中的顺序.**

area函数有不同的子句,当调用函数时会从第一个与调用参数相匹配的子句运行,程序不处理模式失败的情况,当程序以运行错误结束不一定是程序编写错误而是有意为之,让其提前跳出.

### 分号放在哪里 ###

逗号分隔函数调用,数据构造的参数.
分号分隔子句.
句号后接空白分隔函数整体与shell的表达式.

## 继续购物 ##

``[{orange,4},{newspaper,1},{apple,10},{pear,6},{milk,3}]``购物列表

计算模块:
```
-mocule(shop). 
`export([cost/1]). 

cost(orange)    ->5;
cost(newspaper) ->8;
cost(apple)     ->2;
cost(pear)      ->9;
cost(milk)      ->7.
```
计算模块函数由5个子句组成,每个子句头部都有一个模式,当执行shop:cost(X). 时,系统会和各个子句的模式相匹配,如果匹配会执行->右侧的代码.

