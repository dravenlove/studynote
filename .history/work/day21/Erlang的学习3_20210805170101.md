## Erlang速览 ##

## 本章学习任务 ##

**创建一个并发程序,制作一个文件服务器,文件服务器有两个并发进程:一个进程是服务器,另一个为客户端.**

## Shell ##

Shell的每一条表达式都要以**一个句号后接一个空白字符**结束.

### =操作符 ###

用=给变量赋值,但在Erlang中=的用法更像赋值一个变量.

**一旦给一个变量赋值,这个变量的值就固定了不能再重新赋值.**

### 变量和原子的语法 ###

**Erlang的变量以大写字母开头,小写字母开头的名称不是变量而是符号常量,符号常量也叫做原子.**

 函数式编程语言Erlang和命令式编程语言根本区别是:函数式语言变量不能改变,但是命令式语言却可以.

 ## 进程、模块和编译 ##

 Erlang程序由许多并行进程构成.进程任务为执行模块定义的函数,模块是扩展名为.erl的文件,运行前需要先编译他们,编译模块之后可以在shell或操作系统环境中执行模板函数.

### Shell中编译运行Hello World ###

代码我创建在子文件hello.erl:

```
    -module(hello). 
    -export([start/0]). 

    start() ->
        
        io:format("Hello World-n"). 
```

1.我们在erl的Shell终端里用``c(hello). ``编译hello.erl.
终端输出{ok,hello}代表编译成功.

2.代码``hello:start(). ``执行了hello:start()函数.

3.代码``halt(). ``退出Erlang Shell.

### 在Erlang Shell外编译 ###

```
    erlc hello.erl
    erl -noshell -s hello start -s init stop
```

erlc从命令行启动Erlang编译器,编译器编译了hello.erl代码并生成一个叫hello.beam的目标代码文件.

erl -noshell ... 命令加载hello模块,并执行hello:start()函数,然后它执行init:stop()函数,init:stop终止了Erlang会话.

## 并发 ##

Erlang的基本并发单元是进程,一个进程是一个轻量的虚拟机,只能通过发送、接收信息与其他进程通信.

编写一个并发程序"文件服务器":文件服务器要在两台机器之间传输文件,我们需要两个程序:一台机器的客户端和另一台机器的服务端.为了实现,我们会制作两个模块:afile_client和aflie_server.

### 文件服务器进程 ###

文件服务器由一个afile_server模板实现,进程和模块类和对象和类他们的关系类似.
    
进程的代码在模板里,需要创建一个进程需要调用spawn(...),创建进程的操作由这几基本函数完成.

```
    -module(aflie_server). 
    %%模块命名必须和文件名一致
    
    -export([start/1,loop/1]). 
    %%函数定义,函数名/参数数量

    start(Dir) -> spawn(afile_server, loop,[Dir]). 
    %%创建应用程序(模块名,调用函数,调用函数传入参数)

    loop(Dir) ->
        %%等待指令
        receive
            {Client, list_dir} ->
            %%需要做什么
            %%当收到一个进程给他发送信息{客户端进程号,list_dir}他就会执行下面代码.
                Client ! {self(),file:list_dir(Dir)};
            %%向客户端进程号发送信息{当前调用进程号,文件模块下的文件目录函数}
            {Client,{get_file,File}} ->
            %%当收到信息{客户端进程号,File}他会执行以下代码.
                Full = filename:join(Dir, File),
            %%给Full赋值为File的完整目录
                Client ! {self(), file:read_file(Full)}
            %%然后给客户端发信息{当前调用进程号}
        end,
        loop(Dir). 
```

这是一个无限循环.变量Dir包含了文件服务器当前工作目录,我们在循环内等待命令,当收到命令我们会遵从,然后再掉用自身获取下一个命令.

不用担心耗尽栈空间,Erlang对代码采用尾部调用优化:函数的运行空间固定,这是循环的标准方式,只要在最后调用自己就可以.

loop永远不会返回,在顺序语言里无限循环很危险,因为只有一条控制线,但Erlang没有这个问题,因为服务器是一个在无限循环请求处理的程序和其他程序并行处理.

```
 receive
            {Client, list_dir} ->
            %%需要做什么
                Client ! {self(),file:list_dir(Dir)};
            {Client,{get_file,File}} ->
                Full = filename:join(Dir, File),
                Client ! {self(), file:read_file(Full)}
```

这段代码的意思是当接收到{Client,list_dir}消息,就回复一个文件列表,而当接收到{Client,(get_file,File)},就回复这个文件,作为模式匹配的一部分,Client变量在接收到消息时会被赋值.

**要点:**

1.回复对象:所有接收信息都包含变量Client,它是发送请求进程的进程标识符所以他也是回复对象.

2.self()的用法:服务器发送的回复中包含了参数self(),在这个案例中self()是服务器的进程标识符.

标识符附在消息中,客户端可以检查到消息来自服务器而不是某个进程.

3.模式匹配用于选择信息:接收语句内部的两个模式

```
    receive
        Patternl ->
            Actionsl;
        Pattern2 ->
            Actionsl ->
        ...
    end
```

Erlang编译器和运行系统会正确推断如果在收到信息运行适当代码.

用下面命令在shell里编译测试上述代码:

1.创建一个afile_server.erl文件.

2.把上述代码输入到这个文件中.

3.进入erl终端.

4.用``c(afile_server). ``编译这个文件
**注意模块名一定要和文件名一样不然erl编译器会报错.**

5.``FileServer = afile_server:start("."). ``用这行代码创建一个新的并行进程并执行函数afile_server:loop(Dir)返回一个进程标识符,可以用它来进行进程通信.
每次运行这个程序进程标识符都会改变<0.47.0>的数字,这个是进程标识符,他在每个对话里将不一样.

6.``FileServer ! {self(),list_dir}. ``这行命令给FileServer(进程标识符)发送一条{self(),list_dir}消息.Pid ! Message的返回值为Message,故这里shell会打印{self(),list_dir}但实际上它已经给FileServer对应的进程发送了一条信息了.self()
是Erlang自身的进程标识符,它被包含在信息里,告知服务器信息要回复给谁.

7.``receive X -> X end. ``这行代码的意思是接收文件服务器的回复,他返回信息{<x,x,x>,{ok,...}}.元组的第一元素是文件服务器的标识符,第二个是file:list_dir(Dir)函数的返回值,他在文件服务器进程的接收循环得出.

### 客户端代码 ###

文件服务器通过一个名为afile_client的客户端模块进行访问,这个模块的目的是为了隐藏底层通信协议的细节,客户端代码的用户可以通过调用该客户端的模块导出的ls和get_file函数来传输文件,这可以自由改变底层协议而不会影响客户端代码API部分.

```
    -module(afile_client). 
    -export([ls/1,get_file/2]). 

    ls(Server) ->
        Server ! {self(),list_dir},

        receive
            {Service,FileList} ->
                FileList
        end. 

    get_file(Server,File) ->
        Server ! {self(),{get_file,File}},

        receive
            {Server, Content} ->
                Content
        end. 
```

现在重启shell,并重新编译所有代码,展现服务端和客户端怎么共同工作:

1.``FileService = afile_server:start("."). ``这行代码的作用是创建新进程并将返回值赋给FileServer.

2.``afile_client:get_file(FileServer,"missing"). ``这行代码的作用是调用afile_client模块里面的get_file函数,传入参数为FileServer和missing.
然后将执行`` Server ! {self(),{get_file,File}} ``但是File不存在所以会返回错误,和没有该文件错误(enoent).

3.``afile_client:get_file(FileServer,"afile_server.erl"). ``这行代码传入的参数后将返回文件内含有的内容.

## 练习 ##

1.启动并停止Erlang shell.

方法1:命令行输入erl然后ctrl+c退出.

方法2:进入erl shell后halt(). 退出.

2.在Erlang shell输入一些命令.

``erlc  文件名``快速编译.

3.对hello.erl做一些改动并在shell中编译运行他们.

``io:format("see you").``为输出流添加一句话.

4.运行文件客户端和服务器代码,加入一个put_file的命令,你需要添加何种信息.




 




