## Erlang速览 ##

## 本章学习任务 ##

**创建一个并发程序,制作一个文件服务器,文件服务器有两个并发进程:一个进程是服务器,另一个为客户端.**

## Shell ##

Shell的每一条表达式都要以**一个句号后接一个空白字符**结束.

### =操作符 ###

用=给变量赋值,但在Erlang中=的用法更像赋值一个变量.

**一旦给一个变量赋值,这个变量的值就固定了不能再重新赋值.**

### 变量和原子的语法 ###

**Erlang的变量以大写字母开头,小写字母开头的名称不是变量而是符号常量,符号常量也叫做原子.**

 函数式编程语言Erlang和命令式编程语言根本区别是:函数式语言变量不能改变,但是命令式语言却可以.

 ## 进程、模块和编译 ##

 Erlang程序由许多并行进程构成.进程任务为执行模块定义的函数,模块是扩展名为.erl的文件,运行前需要先编译他们,编译模块之后可以在shell或操作系统环境中执行模板函数.

### Shell中编译运行Hello World ###

代码我创建在子文件hello.erl:

```
    -module(hello). 
    -export([start/0]). 

    start() ->
        
        io:format("Hello World-n"). 
```

1.我们在erl的Shell终端里用``c(hello). ``编译hello.erl.
终端输出{ok,hello}代表编译成功.

2.代码``hello:start(). ``执行了hello:start()函数.

3.代码``halt(). ``退出Erlang Shell.

### 在Erlang Shell外编译 ###

```
    erlc hello.erl
    erl -noshell -s hello start -s init stop
```

erlc从命令行启动Erlang编译器,编译器编译了hello.erl代码并生成一个叫hello.beam的目标代码文件.

erl -noshell ... 命令加载hello模块,并执行hello:start()函数,然后它执行init:stop()函数,init:stop终止了Erlang会话.

## 并发 ##

Erlang的基本并发单元是进程,一个进程是一个轻量的虚拟机,只能通过发送、接收信息与其他进程通信.

编写一个并发程序"文件服务器":文件服务器要在两台机器之间传输文件,我们需要两个程序:一台机器的客户端和另一台机器的服务端.为了实现,我们会制作两个模块:afile_client和aflie_server.

### 文件服务器进程 ###

文件服务器由一个afile_server模板实现,进程和模块类和对象和类他们的关系类似.
    
进程的代码在模板里,需要创建一个进程需要调用spawn(...),创建进程的操作由这几基本函数完成.

```
    -module(aflie_server). 
    -export([start/1,loop/1]). 

    start(Dir) -> spawn(afile_server, loop,[Dir]). 

    loop(Dir) ->
        %%等待指令
        receive
            {Client, list_dir} ->
            %%需要做什么
                Client ! {self(),file:list_dir(Dir)};
            {Client,{get_file,File}} ->
                Full = filename:join(Dir, File),
                Client ! {self(), file:read_file(Full)}
        end,
        loop(Dir). 
```

这是一个无限循环.变量Dir包含了文件服务器当前工作目录,我们在循环内等待命令,当收到命令我们会遵从,然后再掉用自身获取下一个命令.

不用担心耗尽栈空间,Erlang对代码采用尾部调用优化:函数的运行空间固定,这是循环的标准方式,只要在最后调用自己就可以.

loop永远不会返回,在顺序语言里无限循环很危险,因为只有一条控制线,但Erlang没有这个问题,因为服务器是一个在无限循环请求处理的程序和其他程序并行处理.

```
 receive
            {Client, list_dir} ->
            %%需要做什么
                Client ! {self(),file:list_dir(Dir)};
            {Client,{get_file,File}} ->
                Full = filename:join(Dir, File),
                Client ! {self(), file:read_file(Full)}
```

这段代码的意思是当接收到{Client,list_dir}消息,就回复一个文件列表,而当接收到{Client,(get_file,File)},就回复这个文件,作为模式匹配的一部分,Client变量在接收到消息时会被赋值.

**要点:**

1.回复对象:所有接收信息都包含变量Client,它是发送请求进程的进程标识符所以他也是回复对象.

2.self()的用法:服务器发送的回复中包含了参数self(),在这个案例中self()是服务器的进程标识符.

标识符附在消息中,客户端可以检查到消息来自服务器而不是某个进程.

3.模式匹配用于选择信息:接收语句内部的两个模式

```
    receive
        Patternl ->
            Actionsl;
        Pattern2 ->
            Actionsl ->
        ...
    end
```

Erlang编译器和运行系统会正确推断如果在收到信息运行适当代码.

用下面命令在shell里编译测试上述代码:

1.创建一个afile_server.erl文件.

2.把上述代码输入到这个文件中.

3.进入erl终端.

4.用c(afile_server). 



